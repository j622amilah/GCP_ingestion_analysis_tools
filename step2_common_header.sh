#!/bin/bash






clear



# ---------------------------
# Functions START
# ---------------------------


# ---------------------------

initial_setup(){

    # Inputs:  
    # 2 csv files
    
    # Step 0: Delete any program related files
    delete_temp_files
    
    # tot_header SHOULD NOT exist, if this function is run
    if [ -f tot_header ]; then
        rm tot_header
    fi 
    
    # Step 1: Get main path
    export cur_path=$(pwd)
    echo "cur_path"
    echo $cur_path
    
    # ****** CHANGE ******
    # export folder_2_organize=$(echo "ingestion_folder/csvdata")
    export folder_2_organize=$(echo "ingestion_folder/csvdata/similar_match_header")
    echo "folder_2_organize"
    echo $folder_2_organize
    
    # Step 2: Get path of folder to search
    export main_path=$(echo "${cur_path}/${folder_2_organize}")
    echo "main_path"
    echo $main_path
    
    cd $main_path
    
    # Step 3: Create a file named file_list that contains all the files in the directory
    create_file_list
    
    # ---------------------
    # Step 4: Create tot_header 
    # ---------------------
    # Get first file from file_list
    export first_filename=$(cat file_list | head -n 1)
    echo "first_filename"
    echo $first_filename  # (ie: 202004-divvy-tripdata.csv)

    # Clean header from csv file and put in a new file
    clean_csv_header $first_filename     # (ie: ride_id \n rideable_type \n started_at)
    # ***** OUTPUT [dummy_name] *****
    
    # ---------------------
    # Step 5: Move first csv file to the exact_match_header folder
    # ---------------------
    export exact_match_header_path=$(echo "${main_path}/exact_match_header")
    if [ ! -d "$exact_match_header_path" ]; then
       echo "exact_match_header does NOT exist."
       mkdir $main_path/exact_match_header
    fi
    mv $main_path/$first_filename $main_path/exact_match_header
    
    mv dummy_name tot_header

    # Remove first_filename from file_list
    cat file_list | sed '/'$first_filename'/d' > temp
    mv temp file_list
    
    # ***** OUTPUT [file_list, tot_header] *****
}


# ---------------------------


create_file_list(){

    # Inputs:  
    # None
    
    # Get list of all csv files in current directory, avoid files generated by program
    ls | sed 's/colBvalue//g' | sed 's/diffrow//g' | sed 's/diff//g' | sed 's/dummy_name//g' | sed 's/file0//g' | sed 's/file1//g' | sed 's/file2//g' | sed 's/file3//g' | sed 's/file4//g' | sed 's/file5//g' | sed 's/file_list//g' | sed 's/filetemp_reevaluate//g' | sed 's/filetemp//g' | sed 's/header2reevaluate_per_row//g' | sed 's/header2//g' | sed 's/header_match_count_per_file//g' | sed 's/header_reduced//g' | sed 's/modelscores//g' | sed 's/new_csv//g' | sed 's/result//g' | sed 's/rows_that_repword_appear//g' | sed 's/sim_float//g' | sed 's/sim_int//g' | sed 's/tempcount//g' | sed 's/to_replace_assignment//g' | sed 's/tot_headerreevaluate_per_row//g' | sed 's/uqtemp//g' | sed 's/test.sh//g' | sed 's/test2.sh//g' | sed 's/test3.sh//g' | sed 's/test4.sh//g' | sed 's/temp//g' | sed 's/tot_header//g' | sed 's/primary_key_list//g' | sed 's/no_match_header//g' | sed 's/test//g' | sed 's/count//g' | sed 's/exact_match_header//g' | sed 's/similar_match_header//g' | sed '/^$/d' > file_list
    
    echo "-----------------------------------"
    echo "file_list:"
    cat file_list
    echo "-----------------------------------"
    
    # ***** OUTPUT [file_list] *****
}


# ---------------------------


clean_csv_header(){

    # Inputs:  
    # $1 = $filename
    
    # ---------------------------------------------
    # Clean header from csv file and put in a new file
    # ---------------------------------------------
    # Get the first line of $first_filename, remove double/single quotes, 
    # replace spaces with underscore
    # remove numbers
    # remove hyphen
    # make lowercase, 
    # remove space at the end,
    # put each word on a newline 
    cat $1 | head -n 1 | sed 's/"//g' | sed "s/'//g" | tr -d [0-9] | sed 's/-//g' | sed 's/  */ /g' | sed 's/^ *//g' | tr '[:upper:]' '[:lower:]' | sed -e '/[[:space:]]\+$/s///' | sed 's/[[:space:]]/_/g' | tr "," '\n' | sort -u > dummy_name  # (ie: ride_id \n rideable_type \n started_at)
    
    
    # Clean csv file header
    export to_replace=$(cat $1 | head -n 1)
    export to_replace_with=$(cat $1 | head -n 1 | sed 's/"//g' | sed "s/'//g" | tr -d [0-9] | sed 's/-//g' | sed 's/  */ /g' | sed 's/^ *//g' | tr '[:upper:]' '[:lower:]' | sed -e '/[[:space:]]\+$/s///' | sed 's/[[:space:]]/_/g')
    # Modify the csv : replaces the word in the entire file
    cat $1 | sed "s/$to_replace/$to_replace_with/g" > new_csv
    mv new_csv $1
        
    # ***** OUTPUT [dummy_name] *****
}

# ---------------------------


# Needs to contain a list of all the files the program creates.

delete_temp_files(){
    
    if [ -f colBvalue ]; then
       rm colBvalue
    fi
    
    if [ -f count ]; then
        rm count
    fi
  
    if [ -f diff ]; then
       rm diff
    fi
  
    if [ -f diffrow ]; then
       rm diffrow
    fi

    if [ -f dummy_name ]; then
       rm dummy_name
    fi
  
    if [ -f file0 ]; then
       rm file0
    fi
  
    if [ -f file1 ]; then
       rm file1
    fi
  
    if [ -f file2 ]; then
       rm file2
    fi
  
    if [ -f file3 ]; then
       rm file3
    fi
    
    if [ -f file4 ]; then
       rm file4
    fi
    
    if [ -f file5 ]; then
        rm file5
    fi
    
    if [ -f filetemp_reevaluate ]; then
        rm filetemp_reevaluate
    fi
    
    if [ -f filetemp ]; then
        rm filetemp
    fi
    
    if [ -f header2reevaluate_per_row ]; then
        rm header2reevaluate_per_row
    fi
    
    if [ -f header_match_count_per_file ]; then
        rm header_match_count_per_file
    fi
    
    if [ -f header_reduced ]; then
        rm header_reduced
    fi
    
    if [ -f modelscores ]; then
        rm modelscores
    fi
    
    if [ -f new_csv ]; then
        rm new_csv
    fi
    
    if [ -f result ]; then
        rm result
    fi
    
    if [ -f rows_that_repword_appear ]; then
        rm rows_that_repword_appear
    fi
    
    if [ -f sim_float ]; then
        rm sim_float
    fi
    
    if [ -f sim_int ]; then
        rm sim_int
    fi
    
    if [ -f temp ]; then
        rm temp
    fi
    
    if [ -f tempcount ]; then
        rm tempcount
    fi
     
    if [ -f test ]; then
        rm test
    fi
    
    if [ -f to_replace_assignment ]; then
        rm to_replace_assignment
    fi
    
    if [ -f tot_headerreevaluate_per_row ]; then
        rm tot_headerreevaluate_per_row
    fi
    
    if [ -f uqtemp ]; then
        rm uqtemp
    fi
    
}


# ---------------------------


compare_a_list_with_a_list(){

    echo "compare_a_list_with_a_list"

    # Inputs:
    # $1 = tot_header (first list)
    # $2 = header2 (second list)
    # $3 = OPTION (0 or 1)
    
    # load tot_header, put bars between words, put in a file named test
    cat $1 | paste -s -d "," | sed 's/,/|,|/g' | sed 's/^/|/g' | sed 's/$/|/g' | tr "," '\n' | tr -d '\r' > test
    

    export n=$(cat $2 | wc -l)
    # echo "n: "
    # echo $n

    for r in $( seq 1 $n )
    do
	# echo "r:"
	# echo $r

	# add bars to define the word
	export genheader_bars1=$(cat $2 | head -n $r | tail -n $(($r-($r-1))) | tr -d '\r' | sed 's/^/|/g' | sed 's/$/|/g')
	# echo "genheader_bars1:"
	# echo $genheader_bars1

	# Count each word in header2 in tot_header
	# Count fixed strings (-F) from a file per line
	export loc_in_curheader=$(grep -n -F $genheader_bars1 test)
	# echo "loc_in_curheader:"
	# echo $loc_in_curheader
	
	# Response if there is a match or no-match
	if [ ! -f $loc_in_curheader ]; then  # means loc_in_curheader is NOT empty (match)

		if [[ $3 -eq "0" ]]; then
		   # Get word directly in header2, genheader_bars1 without bars
		   export to_replace=$(echo $genheader_bars1 | sed "s/|//g")
		   # echo "to_replace:"
		   # echo $to_replace
		   
		   echo "OPTION 0 : loc_in_curheader is NOT empty (match), remove $to_replace from header2"

		   export to_replace_with=$(echo "")
		   # Purposely do not change the length of header2 ( | sed '/^$/d') to keep for loop index
		   cat $2 | sed "s/$to_replace/$to_replace_with/g" > temp
		   mv temp $2
		   
		elif [[ $3 -eq "1" ]]; then
		   # Make a binary file showing which words are in tot_header: 0=not_in_file, 1=in_file
		   echo "OPTION 1 : count"
		   echo 1 >> count
		   
		else
		   echo "OPTION not selected"
		fi

	else # means loc_in_curheader is empty (no match)
		if [[ $3 -eq "0" ]]; then
		   echo "OPTION 0 : loc_in_curheader is empty (no match), leave $genheader_bars1 in header2"
		   
		elif [[ $3 -eq "1" ]]; then
		   # No match found, insert null column
		   echo "OPTION 1 : count"
		   echo 0 >> count
		   
		else
		   echo "OPTION not selected"
		fi

	fi

    done
    
    rm test
    
    # IF option=0, OUTPUT = temp
    # IF option=1, OUTPUT = count
}


# ---------------------------


reduce_header2_to_unique_words(){

    echo "reduce_header2_to_unique_words"
    # Inputs:  
    # header2  # file (ie: ride_id \n rideable_type \n started_at)
    # tot_header  # file (ie: ride_id \n rideable_type \n started_at)
    
    export OPTION=$(echo "0")
    
    compare_a_list_with_a_list tot_header header2 $OPTION
    # OUTPUT : temp 
    
    # Remove white/empty space at the end : an empty file means that all the words in header2 were in tot_header
    cat header2 | sed '/^$/d' > temp
    mv temp header2
    
    # Print header2
    echo "-----------------------------------"
    echo "header2 : AFTER reduce_header2_to_unique_words"
    cat header2
    echo "-----------------------------------"
    
# ***** OUPUT : replaced version of header2 (where only values are lexically different than tot_header)
}


# ---------------------------


# Considers substring match of words
word2substrs(){

    # Inputs:  
    # $1 = f_row
    
    # Get the character length of the word
    export len=$(echo -n "$1" | wc -m)  # *** for the function we use $1 for the input $f_row ***
    # echo "len"
    # echo $len
    
    cnt0=0  ### IT starts from 0 unlike an array ###
    cnt1=2 # **** reset inner loop **** 0
    while [ $cnt0 -le $len ]
    do
       # echo "cnt0:"
       # echo $cnt0
       
       while [ $cnt1 -le $len ]
       do
         # echo "cnt1:"
         # echo $cnt1
       
         # ${string:start_position:sub_strwidth} 
         out=${1:$cnt0:$cnt1}  # *** for the function we use $1 for the input $f_row ***
         # echo "out:"
         # echo $out
         
         # Creates the file result and closes it
         echo $out >> result
         cnt1=$((cnt1+1))
       done
       
       cnt1=2  # **** reset inner loop ****
       cnt0=$((cnt0+1))
    done

    # Opens result, Remove white spaces, puts contents into temp (*** can not save directly to result***)
    cat result | sed '/^$/d' > temp
    mv temp result # *** resave over result ***
    
    # ***** OUTPUT [result] *****
}


# ---------------------------


substring_evaluation(){
    
    echo "substring_evaluation"
    
    # Inputs:  
    # $1 = $f_row               # environmental variable (ie: ride_id from header2 file)
    # $2 = tot_header           # file (ie: ride_id \n rideable_type \n started_at)
    
    # ---------------------------
    if [ -f header_match_count_per_file ]; then
      rm header_match_count_per_file
    fi
    # ---------------------------
    
    for h_row in $(cat $2)
      do
        # ---------------------------
        # cut the word in $f_row into substrings : creates result with substrings
        word2substrs $1
        # OUTPUT : result
        # ---------------------------
        
        # ---------------------------
        if [ -f temp ]; then
          rm temp
        fi
        # ---------------------------
        
        # ---------------------------
        # Must put the row header word in a file
        echo $h_row > temp
        
        sum=0
        for ss in $(cat result)
        do
          export count=$(grep $ss temp | wc -l)
          sum=$((sum  + $count))
        done
        
        rm temp
        rm result
        
        # Now we have the sum of the filename substrings per header : should be as long as header
        echo $sum >> header_match_count_per_file
        # ---------------------------
     
    done  # end of h_row
      
      
    # ---------------------------
    # Way 1: assign header rows to file rows based on a comparative count threshold in header_match_count_per_file
      
    # Take the average of header_match_count_per_file
    export sum=$(cat header_match_count_per_file | paste -s -d "+" | bc)
    export N=$(wc header_match_count_per_file |cut -d ' ' -f 2)

    export avg=$(echo "scale=0;$sum/$N" | bc)
    # echo "avg: "
    # echo $avg
    # -------------------------------------
      
    # -------------------------------------
    if [ -f header_reduced ]; then
      rm header_reduced
    fi
      
    if [ -f tempcount ]; then
      rm tempcount
    fi
    # -------------------------------------
      
    # -------------------------------------
    # Select all the rows in header that have a count greater than the average of header_match_count_per_file
    r=1
    for h_row_count in $(cat header_match_count_per_file)
    do
      if [[ $h_row_count -ge $avg ]]; then
          # echo "h_row_count: "
          # echo $h_row_count
          
          # Append the header2 words that have average substring counts greater than average per f_row (word in header2)
          cat $2 | head -n $r | tail -n $(($r-($r-1))) >> header_reduced
          
          echo $h_row_count >> tempcount
      fi
      r=$((r+1))
    done
      
    rm header_match_count_per_file
    # -------------------------------------
      
    # ***** OUTPUT : [header_reduced, tempcount] *****
}


# ---------------------------


model_evaluation(){

    echo "model_evaluation"

    # Inputs:  
    # $1 = $f_row                         # environmental variable (ie: ride_id from header2 file)
    # $2 = $header_reduced_list           # environmental variable (ie: ride_id,rideable_type,started_at from tot_header file)
    # $3 = $header_count_list_reduced     # environmental variable (ie: 89,34,29 via substring_evaluation)
    
    # ---------------------------
    # Step 0: put header2 word and list of words from tot_header in format for Hugging Face model: words need double quotes
    # ---------------------------
    # Add double quotes to header2 selected word
    export f_row_quotes=$(echo $1 | sed 's/^/"/g' | sed 's/$/"/g' | tr -d '\r')
    # echo "f_row_quotes: "
    # echo $f_row_quotes
    
    # Add double quotes to list of words from tot_header selected words
    export header_list_reduced_quotes=$(echo $2 | sed 's/^/"/g' | sed 's/,/","/g' | sed 's/$/"/g' | tr -d '\r')
    # echo "header_list_reduced_quotes: "
    # echo $header_list_reduced_quotes
    # ---------------------------
    
    
    # ---------------------------
    # Step 1: calculate word similarity, put similarity output in a file
    # How to use Hugging Face REST APIs : https://huggingface.co/docs/api-inference/detailed_parameters
    # ---------------------------
    export HF_API_TOKEN=$(echo "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")
      
    curl https://api-inference.huggingface.co/models/sentence-transformers/all-MiniLM-L6-v2 \
         -X POST \
         -d '{"inputs":{"source_sentence": '$f_row_quotes', "sentences": ['$header_list_reduced_quotes']}}' \
         -H "Authorization: Bearer ${HF_API_TOKEN}" | cut -b 2- | sed 's/.$//' | tr "," '\n' > sim_float
    # ---------------------------
    
    
    # ---------------------------
    # Step 2: calculate the max similarity in integer format 
    
    # Printing
    # echo "sim_float"
    # cat sim_float
    
    # Transform list of float similarity values to a list of integer values
    for csim in $(cat sim_float)
    do 
      echo "scale=0;$csim*100" | bc | cut -d '.' -f 1 >> sim_int
    done
    rm sim_float
    
    # Printing
    # echo "sim_int"
    # cat sim_int  # vector as long as $header_list_reduced_quotes
      
    # Maximum similarity as an integer (scalar)
    max=$(cat sim_int | sort -nr | head -n1)
    # echo "max: "
    # echo $max
    # ---------------------------
     
    # ---------------------------
    # Step 3: Selection of most similar word based on : 0) maximum similarity within each category, 1) similarity > 70
    # NOTE : filetemp is CREATED below 
    # ---------------------------
    # Make a non-double quote list of tot_header words for filetemp
    export header_list_reduced_noquotes=$(echo $header_list_reduced_quotes | sed 's/"//g' | tr -d '\r')
    
    c=1  # ****** ALL vectors start at 1 ******
    for csim in $(cat sim_int)
    do
        if [[ $csim == $max ]] && [[ $csim -gt 70 ]]; then
            
          export to_replace=$(echo $1)
          export to_replace_with=$(cat header_reduced | head -n $c | tail -n $(($c-($c-1))))
           
          # Way 1
          export sim_int_concat=$(cat sim_int | paste -s -d "," | tr -d '\r')
          echo $to_replace' '$to_replace_with' '$3' '$csim' '$sim_int_concat' '$header_list_reduced_noquotes >> filetemp
        else
            # Append spaces in filetemp
            echo "" >> filetemp
        fi
        c=$((c+1))
    done
    
    rm sim_int
    rm header_reduced  # header_reduced contains header values where substring were greater than avg
    # ---------------------------
    
    # ***** OUTPUT [filetemp] *****
}


# ---------------------------


similarity_assignment(){

    echo "similarity_assignment"

    # Inputs:  
    # $1 = header2  # file (ie: ride_id \n rideable_type \n started_at)
    # $2 = tot_header  # file (ie: ride_id \n rideable_type \n started_at)
    
    # *** The filenames are not used because this function is called many times with other filenames ***
    
    # echo "Verify header2 values: "
    # cat $1
    
    # Purpose : Fills header file with headeronly words
    for f_row in $(cat $1)
    do
      # echo "header2 word (f_row): "
      # echo $f_row
      
      # ---------------------------
      # Step 0: Calculate stubstrings
      echo "-----------------------------------"
      substring_evaluation $f_row $2
      # OUTPUT : header_reduced, tempcount
      echo "-----------------------------------"
      
      # echo "-----------------------------------"
      # Print similar words based on lexical substring similarity
      # echo "header_reduced + tempcount: $f_row"
      # paste header_reduced tempcount -d ","  > viewingtemp
      # cat viewingtemp
      # rm viewingtemp
      # echo "-----------------------------------"
      # ---------------------------
      
      # ---------------------------
      # Step 1: Make string list of header_reduced (words in header2)
      export header_reduced_list=$(cat header_reduced | paste -s -d "," | tr -d '\r')
      # echo "header_reduced_list: "
      # echo $header_reduced_list
      
      # header_reduced is not yet deleted bacause it is needed in model_evaluation
      # ---------------------------
      
      # ---------------------------
      # Step 2: Make string list of tempcount (substring counts)
      export header_count_list_reduced=$(cat tempcount | paste -s -d "," | tr -d '\r')
      # echo "header_count_list_reduced: "
      # echo $header_count_list_reduced
      
      rm tempcount
      # ---------------------------
      
      # ---------------------------
      # Step 4: Run the model
      echo "-----------------------------------"
      model_evaluation $f_row $header_reduced_list $header_count_list_reduced
      echo "-----------------------------------"
      echo "END of model_evaluation: filetemp"
      cat filetemp
      echo "-----------------------------------"
      # ***** OUTPUT [filetemp] *****
      
      # Remove empty spaces from rows
      cat filetemp | sed '/^$/d' > temp
      mv temp filetemp
      # ---------------------------
      
    done  # end of f_row
    
    # ***** OUTPUT [filetemp] *****
}


# ---------------------------


check_for_identical_columns_in_tot_header_header2(){

    echo "check_for_identical_columns_in_tot_header_header2"
    
    # Move the file into one of the three: exact_match_header, similar_match_header, no_match_header
    
    # Can have several criterial:
    # [0] Easy : exact_match_header (UNION)
    #
    # [1] Hard : similar_match_header (at least 1 column has to match to do a JOIN)
    #
    # [2] no_match_header
        
    # Inputs:
    # $1 = filename
    # header2  # file (ie: ride_id \n rideable_type \n started_at)
    # tot_header  # file (ie: ride_id \n rideable_type \n started_at)
    
    if [ -f count ]; then
        rm count
    fi
    
    export OPTION=$(echo "1")
    
    compare_a_list_with_a_list tot_header header2 $OPTION
    # OUTPUT : count 
}


# ---------------------------


colAselection_colBoutput(){

    echo "colAselection_colBoutput"
    
    # ----------------------
    # Equivalent usage with awk: but unreliable sometimes (gives a syntax error sometimes)
    # ----------------------
    # Using file difftemp, select col1, search for $min_lex_cnt_diff, output col2 aligned value
    # export colBvalue=$(cat difftemp | awk '{if($1=='$min_lex_cnt_diff'){print $2}}')
    
    # ----------------------
    # Example usage
    # ----------------------
    # export file_name=$(echo 'difftemp')
    # export select_colnum=$(echo '1')
    # export select_colnum_pattern_search=$(echo $min_lex_cnt_diff)
    # export aligned_output_colnum=$(echo '2')
    
    # Logic : if column1==x, select corresponding column2 value
    
    # Inputs:  
    # $1 = file_name [file with a matrix structure]
    # $2 = select_colnum [column number to search for a string pattern match]
    # $3 = $select_colnum_pattern_search [string pattern]
    # $4 = $aligned_output_colnum [output column number where one desires to have the value aligned with the row where the string pattern was found]
    
    r=1
    export colBvalue=$(echo "")
    for i in $(cat $1)
    do
       export colA_search_pattern=$(echo $3)
       export colB_desired_output=$(cat $1 | cut -d ' ' -f $4 | head -n $r | tail -n $(($r-($r-1))))
       export row_format=$(echo $i | cut -d ' ' -f $2 | head -n $r | tail -n $(($r-($r-1)))) # select column 1, and variable row 
       
       if [ $row_format == $colA_search_pattern ]; then
          export colBvalue1=$(echo $colB_desired_output) # there should be only one match so store the value one time
          export colBvalue=$(echo $colBvalue" "$colBvalue1)
       fi
       r=$((r+1))
    done
    
    echo $colBvalue > colBvalue
    # return $colBvalue
}




# ---------------------------
# Reevaluation
# ---------------------------

get_to_replace_assignment(){
    
    echo "get_to_replace_assignment"
    
    # Inputs:
    # $1 = $repword
    # $2 = $maxvalue
    # $3 = $count
    # rows_that_repword_appear
    # filetemp
    

    # [file and csv modification] assign repword to the value of to_replace in the row (in file and the csv)
    if [[ $3 -gt 1 ]]; then
       # If the model predicts two or more matches EQUALLY : select the row with the minimum lexical difference 
       
       echo "Model predicts two or more matches EQUALLY"
       
       for r in $(cat rows_that_repword_appear)
       do 
          # echo "r: "
          # echo $r
          
          export maxscore=$(cat filetemp | cut -d ' ' -f 4 | head -n $r | tail -n $(($r-($r-1))))
          # echo "maxscore: "
          # echo $maxscore
          
          if [ $maxscore == $2 ]; then
              
              # NOTE : $3 corresponds to the 3rd column in filetemp, NOT $count
              export maxcount_per_row=$(cat filetemp | awk '{print $3}' | head -n $r | tail -n $(($r-($r-1))) | tr "," '\n' | sort -n | tail -n 1)
              # echo "maxcount_per_row: "
              # echo $maxcount_per_row
          
              export mincount_per_row=$(cat filetemp | awk '{print $3}' | head -n $r | tail -n $(($r-($r-1))) | tr "," '\n' | sort -n | head -n 1)
              # echo "mincount_per_row: "
              # echo $mincount_per_row
          
              echo "scale=0;$maxcount_per_row-$mincount_per_row" | bc >> diff
              echo $r >> diffrow
          fi
       done
       
       rm rows_that_repword_appear
       
       if [ -f difftemp ]; then
          rm difftemp
        fi
        
       # Construct a matrix of these values: difftemp=[diff difftemp]  
       paste diff diffrow -d " " >> difftemp
       rm diff diffrow
       
       # echo "difftemp"
       # cat difftemp
       
       # Find the min value of column 1 of difftemp [minimum lexical count difference]
       export min_lex_cnt_diff=$(cat difftemp | awk '{print $1}' | sort -n | head -n 1)
       # echo "min_lex_cnt_diff"
       # echo $min_lex_cnt_diff
       
       # Using file difftemp, select col1, search for $min_lex_cnt_diff, output col2 aligned value
       export file_name=$(echo 'difftemp')
       export select_colnum=$(echo '1')
       export select_colnum_pattern_search=$(echo $min_lex_cnt_diff)
       export aligned_output_colnum=$(echo '2')
       colAselection_colBoutput $file_name $select_colnum $select_colnum_pattern_search $aligned_output_colnum
       export rowdes=$(cat colBvalue)  # output of function
       
       rm colBvalue
       
       # echo "rowdes: "
       # echo $rowdes
       
       rm difftemp
       
       # Want to replace to_station_id with $repword=end_station_id : row $resdes, column filetemp
       export to_replace_assignment=$(cat filetemp | cut -d ' ' -f 1 | head -n $rowdes | tail -n $(($rowdes-($rowdes-1))))
       # echo "to_replace_assignment: "
       # echo $to_replace_assignment
       
    else
       echo "Model predicts two or more matches NON-EQUALLY"
       echo "there is a max modelscore value: "
              
       # If the model predicts two or more matches NON-EQUALLY (max_score_values has one maximum) : model assigns one header value to a file value based on meaning/context
       
       # There could be multiple repword in column 2 , find column2=repword and column4=maxvalue, output col1
       r=1
       for line_in_file in $(cat filetemp)
       do 
          # Select the entire row in filetemp
          export col1=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 1 | tr -d '\r')
          export col2=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 2 | tr -d '\r')
          export col4=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 4 | tr -d '\r')
          
          if [[ $col2 == $1 ]] && [[ $col4 == $2 ]]; then
            export to_replace_assignment=$(echo $col1)
          fi
          r=$((r+1))
       done
      
       # echo "to_replace_assignment: "
       # echo $to_replace_assignment
    fi
    
    echo $to_replace_assignment > to_replace_assignment
    #return $to_replace_assignment
    
    # ***** OUTPUT [to_replace_assignment] *****
}

# ---------------------------

get_modelscores_for_repword(){

    echo "get_modelscores_for_repword"
    
    # Inputs:  
    # filetemp
    # rows_that_repword_appear

    export modelscores=$(echo '')

    for r in $(cat rows_that_repword_appear)
    do
       export temp=$(cat filetemp | cut -d ' ' -f 4 | head -n $r | tail -n $(($r-($r-1))))
       export modelscores=$(echo $modelscores' '$temp)
    done
    
    # ***** OUTPUT : [modelscores] *****
    
    # return $modelscores  # output variable did not work
    echo $modelscores > modelscores  # so output to a file
}

# ---------------------------

modify_filetemp_header2(){

    echo "modify_filetemp_header2"

    # Inputs:  
    # $1 = $repword
    # $2 = $to_replace_assignment
    # header2  # file (ie: ride_id\nrideable_type\nstarted_at)
    # filetemp
    
    # -------------------------
    # Modify filetemp : main match assignment (replace [file=to_replace=column 1 of filetemp] with [best match header=repword=to_replace_with=column 2 of filetemp] )
    # -------------------------
    # Modify header2 : replaces the word in the entire file
    export to_replace_with_assignment=$(echo $1)
    # echo "to_replace_with_assignment"
    # echo $to_replace_with_assignment
    
    # echo "Confirm contents of header2 BEFORE to_replace_with_assignment:"
    # cat header2
    
    cat header2 | sed "s/$2/$to_replace_with_assignment/g" > temp
    mv temp header2

    # Modify the csv : replaces the word in the entire file
    cat $filename | sed "s/$2/$to_replace_with_assignment/g" > new_csv
    mv new_csv $filename
    
    # echo "Confirm contents of header2 AFTER to_replace_with_assignment:"
    # cat header2
    # -------------------------

    # -------------------------
    # [0] Modify filetemp column values : 
    echo "Modify filetemp column values:"
    
    # 1. remove [best match header word=repword] VALUE from columns 3, 4, 5
    # Get length of filetemp
    export n=$(cat filetemp | wc -l)
    # echo "n: "
    # echo $n
    
    for r in $( seq 1 $n )
    do 
      # Select the entire row in filetemp
      export col1_before=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 1 | tr -d '\r')
      export col2_before=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 2 | tr -d '\r')
      export col3_before=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 3 | tr -d '\r') # do not erase the substring count values
      # export col4_before=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 4 | tr -d '\r')
      # export col5_before=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 5 | tr -d '\r')
      # export col6_before=$(cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 6 | tr -d '\r')
      
      # After assignment : signifies that this row needs to be re-evaluated for a file-header match
      
      # If col2_before == repword, replace with X,
      if [ $col2_before == $1 ]; then
         export col2_after=$(echo 'X')
      else
         export col2_after=$(echo $col2_before)
      fi
      
      # Make matrix of columns 3,5,6
      cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 3 | tr "," '\n' >> file0
      cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 5 | tr "," '\n' >> file1
      cat filetemp | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 6 | tr "," '\n' >> file2
      paste file0 file1 file2 -d " " >> file3
      
      # Remove [best match header word=repword] from column 6
      cat file3 | sed "/$1/d" > file4
      
      #export col3_after=$(cat file4 | cut -d ' ' -f 1 | paste -s -d "," | tr -d '\r')
      export col5_after=$(cat file4 | cut -d ' ' -f 2 | paste -s -d "," | tr -d '\r')
      export col6_after=$(cat file4 | cut -d ' ' -f 3 | paste -s -d "," | tr -d '\r')
      
      # Recalculate max for column 4 using the updated column 5
      export col4_after=$(cat file4 | cut -d ' ' -f 2 | sort -n | tail -n 1 | tr -d '\r')
      
      export to_replace=$(cat filetemp | head -n $r | tail -n $(($r-($r-1)))| tr -d '\r')
      # echo "to_replace"
      # echo $to_replace
      
      export to_replace_with=$(echo $col1_before' '$col2_after' '$col3_before' '$col4_after' '$col5_after' '$col6_after)
      # echo "to_replace_with"
      # echo $to_replace_with
      
      # Update filetemp
      cat filetemp | sed "s/$to_replace/$to_replace_with/g" > file5
      mv file5 filetemp
      
      rm file0 file1 file2 file3 file4
    done
    
    # echo "filetemp after removing repword:"
    # cat filetemp
    # -------------------------

    # -------------------------
    # [1] Modify filetemp row values 
    # -------------------------
    # [filetemp modification] delete the row that was assigned from filetemp

    # Use the to_replace value because these are unique values from file.
    cat filetemp | sed "/$2/d" > temp
    mv temp filetemp
    
    # -------------------------
    
    # ***** OUTPUT [filetemp] *****
 }

# ---------------------------

reevaluation_assignment(){

    echo "reevaluation_assignment"

    # Inputs:
    # filetemp
        
    # -------------------------
    # When it falls out only unique and unassigned values of to_replace_with are left - reevalutate with model score
    
    # Make a temporary new "header2" with remaining col1 words
    cat filetemp | awk '{print $1, $6}' > filetemp_reevaluate
    
    # Delete filetemp for it to be recreated in similarity_assignment:model_evaluation
    rm filetemp
    
    # Get length of filetemp_reevaluate
    export n=$(cat filetemp_reevaluate | wc -l)
    # echo "n: "
    # echo $n
    
    for r in $( seq 1 $n )
    do  
        cat filetemp_reevaluate | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 1 | tr -d '\r' > header2reevaluate_per_row 
        # echo "Verify header2reevaluate_per_row: "
        # cat header2reevaluate_per_row
        
        cat filetemp_reevaluate | head -n $r | tail -n $(($r-($r-1))) | cut -d ' ' -f 2 | tr -d '\r' | sed 's/,/ /g' | sed -Ee '/[[:space:]]+$/s///' | sed 's/ /\n/g'  > tot_headerreevaluate_per_row
        
        # echo "Verify tot_headerreevaluate_per_row: "
        # cat tot_headerreevaluate_per_row
        
        # Re-run
        similarity_assignment header2reevaluate_per_row tot_headerreevaluate_per_row
        # ***** OUTPUT [filetemp] *****
        
        # echo "filetemp during reevaluation_assignment LOOP :"
        # cat filetemp
        
        rm header2reevaluate_per_row tot_headerreevaluate_per_row
    done
    
    rm filetemp_reevaluate
    
    # echo "filetemp after RUNNING reevaluation_assignment :"
    # cat filetemp
    # -------------------------
}

# ---------------------------

evaluation_reevaluation_assignment(){

    echo "evaluation_reevaluation_assignment"

    # Inputs:
    # filetemp
    # header2  # file (ie: ride_id\nrideable_type\nstarted_at)
        
    # -------------------------
    # Evaluation of assignment and reassignment
    # -------------------------
    # Evaluation of model score matches, to prevent no repeating matches and logical (lexical, meaning) matches
    # Stay in while loop until all header2 values [column 1 in filetemp] have matches
    
    # Check if filetemp is empty: break loop
    export empty=$(cat filetemp | wc -l)
    while [[ $empty != 0 ]]
    do
        # Get unique column 2 values [best match header=repword=to_replace_with=column 2 of filetemp]
        cat filetemp | cut -d ' ' -f 2 | sort -u | tr " " '\n' > uqtemp
        
        # echo "uqtemp: "
        # cat uqtemp
        
	# Loop over the unique tot_header words that the model said could be assigned to header2 words
        for repword in $(cat uqtemp)
        do
           # -------------------------
           echo "repword: "
           echo $repword
           # -------------------------
           
           # -------------------------
           # Get the rows of filetemp for repword
           # export rows_that_repword_appear=$(cat filetemp | cut -d ' ' -f 2 | sed -n '/'$repword'/=')
           cat filetemp | cut -d ' ' -f 2 | sed -n '/'$repword'/=' | tr " " '\n' > rows_that_repword_appear
           # echo "rows_that_repword_appear: "
           # cat rows_that_repword_appear
           
           # Get model scores for repword
           get_modelscores_for_repword
           # ***** OUTPUT : [modelscores] *****
           
           export modelscores=$(cat modelscores)  # OUTPUT of function
           # echo "modelscores: "
           # echo $modelscores
           
           # Get the maxvalue of model scores for repword
           export maxvalue=$(echo $modelscores | tr " " '\n' | sort -n | tail -n 1)
           # echo "maxvalue: "
           # echo $maxvalue
           
           # Check if the maxvalue repeats, to find cases where the model equally interprets a match
           export count=$(grep -o $maxvalue <<<"$modelscores" | grep -c .)
           # echo "count: "
           # echo $count
           # -------------------------
           
           get_to_replace_assignment $repword $maxvalue $count
           # ***** OUTPUT [to_replace_assignment] *****
           
           export to_replace_assignment=$(cat to_replace_assignment)  # OUTPUT of function
           rm to_replace_assignment
           echo "to_replace_assignment: "
           echo $to_replace_assignment
           
           # -------------------------
           
           # Assign model score matches to header2/csv, delete model score matches from filetemp
           modify_filetemp_header2 $repword $to_replace_assignment
           # OUTPUT : filetemp (should become empty exactly at the last loop)
           
           # echo "filetemp after deleting matched row:"
           # cat filetemp
           
        done # END for loop [for repword in $(cat uqtemp)]

        # OUTPUT : header2, filetemp
        
        # -------------------------
        
        # Check if filetemp is empty: break loop
        export empty=$(cat filetemp | wc -l)
        
        # OR
        
        if [[ $empty != 0 ]]; then
            
            reevaluation_assignment
            # ***** OUTPUT [filetemp] *****
            
            
            
            # Check if filetemp is empty: break loop
            export empty=$(cat filetemp | wc -l)
            
            if [[ $empty != 0 ]]; then
                echo "**** filetemp contains entries : redo evaluation_reevaluation_assignment ****"
            else
                break  # break while loop
            fi
            
        else
            break  # break while loop
        fi

    done # END while loop [while [[ $empty != 0 ]]]
}


# ---------------------------



# ---------------------------
# Functions END
# ---------------------------

















# [Step 0] Obtain a global header [tot_header] for similarily labeled datasets 
initial_setup
# ***** OUTPUT [file_list, Create tot_header] *****

echo "-----------------------------------"
echo "tot_header : AFTER clean_csv_header"
cat tot_header
echo "-----------------------------------"


# Loop through the list of csv files in the directory
for filename in $(cat file_list)
do
    echo "filename: "  
    echo $filename  # (ie: 202005-divvy-tripdata.csv)
    
    # [Step 1: Create header2] Clean header from csv file and put in a new file
    clean_csv_header $filename     # (ie: ride_id \n rideable_type \n started_at)
    mv dummy_name header2
    
    echo "-----------------------------------"
    echo "header2 : AFTER clean_csv_header"
    cat header2
    echo "-----------------------------------"
    
    # --------------------------
    # [Step 2] Make temporary environmental variables for tot_header and header2
    
    # String list
    echo "-----------------------------------"
    tot_header_ev=$(cat tot_header | paste -s -d "," | tr -d '\r')
    echo "tot_header_ev: "  
    echo $tot_header_ev
    echo "-----------------------------------"
    # --------------------------
    
    # --------------------------
    # String list
    echo "-----------------------------------"
    header2_ev=$(cat header2 | paste -s -d "," | tr -d '\r')
    echo "header2_ev: "  
    echo $header2_ev
    echo "-----------------------------------"
    # --------------------------
    
    # [Step 3] Check if tot_header and header2 have text
    if [[ -n "$tot_header_ev" ]] || [[ -n "$header2_ev" ]]; then
        echo "[Step 3] tot_header and header2 are NOT EMPTY, continue with ingestion"
        
        # ----------------------------------------------------------------------------
        # [Step 4] Check if tot_header == header2
        if [[ "$tot_header_ev" != "$header2_ev" ]]; then
            echo "-----------------------------------"
            echo "[Step 4] tot_header != header2"
            
            unset $tot_header_ev
            unset $header2_ev
            
            # [Step 5] Check if words in header2 are in tot_header
            echo "[Step 5] reduce_header2_to_unique_words"
            reduce_header2_to_unique_words
            
            echo "number of lines remaining in header2 (if greater than zero do similarity_assignment)"
            num_lines_in_header2=$(cat header2 | wc -l)
            echo $num_lines_in_header2
            
            # [Step 6] Check if header2 is empty: if header2 is empty GO TO NEXT FILE.  IF header2 is NOT empty, do similarity.
            if [[ $num_lines_in_header2 -gt "0" ]]; then
                echo "-----------------------------------"
            	echo "[Step 6] header2 is NOT empty: do similarity_assignment"
            	
            	
            	# Need an example when header2 is not empty
		# Correct words in header2 that may have the same meaning as words in tot_header
		similarity_assignment header2 tot_header
		# OUTPUT : filetemp -- the file contains model score matches
		
		# Ensure that filetemp exists
		if [ -f filetemp ]; then
		    evaluation_reevaluation_assignment
		fi
		# OUTPUT : header2 (where tot_header was compared with header2, and SIMILAR matches were saved to header2)
		
		# [Step 7] Determine whether header2 and tot_header should be joined/concatenated
		# If at least one column is identical, join the headers. 
		# For SQL ingestion, these files/tables can all be joined on using a primary key on GCP.  
		check_for_identical_columns_in_tot_header_header2
    		# ***** OUTPUT [count] *****
    		
    		
    		# Sum to get total number of header2 words in tot_header
		export sum=$(cat count | paste -s -d "+" | bc)
		echo "sum: "
		echo $sum

		# ---------------------------
		if [[ "$sum" -gt "0" ]]; then
		echo "There are some header2 words in tot_header : merge the headers"

		# Choices: 
		# 0) DO NOT modify tot_header and do similar_match_header (can only JOIN (append columns) and can not UNION (append rows))

		# 1) Modify tot_header with similar m 
		# Update tot_header with header2 values : one or more header2 values are in tot_header
		# cat tot_header header2 | sort -u | sed '/^$/d' > temp
		# mv temp tot_header

		export similar_match_header_path=$(echo "${main_path}/similar_match_header")
		if [ ! -d "$similar_match_header_path" ]; then
		 echo "similar_match_header does NOT exist."
		 mkdir $main_path/similar_match_header
		fi
		mv $main_path/$filename $similar_match_header_path

		else
		echo "There are NO header2 words in tot_header : put $1 in no_match_header folder"
		# Move the csv to another folder : NO header2 values are in tot_header

		export no_match_header_path=$(echo "${main_path}/no_match_header")
		if [ ! -d "$no_match_header_path" ]; then
		 echo "no_match_header does NOT exist."
		 mkdir $main_path/no_match_header
		fi
		mv $main_path/$filename $no_match_header_path

		fi
		# ---------------------------
    		
    		
		
            else
                echo "-----------------------------------"
		echo "[Step 6] header2 is EMPTY: Go to next file"
            fi
            
            
        else
            # tot_header == header2
            echo "-----------------------------------"
            echo "[Step 4] tot_header == header2, Go to next file"
            mv $main_path/$filename $exact_match_header_path
        fi
        # ----------------------------------------------------------------------------
        
    else
        echo "[Step 3] tot_header and/or header2 are EMPTY, Put file in empty_header folder, Go to next file"
        mkdir empty_header
        mv $filename empty_header
    fi
    
    
    # --------------------------
    # [Step 8] Delete all files for next filename
    delete_temp_files
    
    if [ -f header2 ]; then
        rm header2
    fi
    # --------------------------
    
done # end of [for filename in $(cat folder_list2)]

# ----------------------------------------------------------------------------

# [Step 9] Calculate the primary key [one of words in tot_header] with respect to all the csv files

# Redo file_list, because it is missing one file
# create_file_list




# ----------------------------------------------------------------------------

# [Step 10] Reorganize the csv file, so that they all have at least the [primary key] and columns from the tot_header schema





# ***** OUTPUT [more csv files in the folder because we can only concatenate 12 columns per csv file]. tot_header has 20+ columns, thus each csv file using tot_header needs to be put into TWO csv files [primary_key, 11 columns] and [primary_key, 8+ columns]








